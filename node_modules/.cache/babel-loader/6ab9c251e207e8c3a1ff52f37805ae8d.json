{"ast":null,"code":"const type = x => Object.prototype.toString.call(x).slice(8, -1);\n\nconst isEmpty = x => type(x) === 'Object' && Object.keys(x).length === 0 || type(x) === 'Null' || type(x) === 'Undefined';\n\nconst get = (path, obj, defaultValue) => {\n  const head = path[0];\n  const tail = path.slice(1);\n\n  if (!tail.length) {\n    return isEmpty(obj[head]) ? defaultValue : obj[head];\n  }\n\n  return get(tail, obj[head], defaultValue);\n};\n\nconst withMinAndMaxMedia = (x, y) => `@media (min-width: ${x}) and (max-width: ${y})`;\n\nconst makeErrorMessage = (breakName, breaks) => `'${breakName}' is invalid breakpoint name. Use '${Object.keys(breaks).join(', ')}'.`;\n\nmodule.exports = {\n  type,\n  get,\n  withMinAndMaxMedia,\n  makeErrorMessage,\n  isEmpty\n};","map":{"version":3,"sources":["/home/gritter/Desktop/Personal Projects/portfolio/node_modules/styled-breakpoints/core/library.js"],"names":["type","x","Object","prototype","toString","call","slice","isEmpty","keys","length","get","path","obj","defaultValue","head","tail","withMinAndMaxMedia","y","makeErrorMessage","breakName","breaks","join","module","exports"],"mappings":"AAAA,MAAMA,IAAI,GAAIC,CAAD,IAAOC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BJ,CAA/B,EAAkCK,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAApB;;AAEA,MAAMC,OAAO,GAAIN,CAAD,IACbD,IAAI,CAACC,CAAD,CAAJ,KAAY,QAAZ,IAAwBC,MAAM,CAACM,IAAP,CAAYP,CAAZ,EAAeQ,MAAf,KAA0B,CAAnD,IACAT,IAAI,CAACC,CAAD,CAAJ,KAAY,MADZ,IAEAD,IAAI,CAACC,CAAD,CAAJ,KAAY,WAHd;;AAKA,MAAMS,GAAG,GAAG,CAACC,IAAD,EAAOC,GAAP,EAAYC,YAAZ,KAA6B;AACvC,QAAMC,IAAI,GAAGH,IAAI,CAAC,CAAD,CAAjB;AACA,QAAMI,IAAI,GAAGJ,IAAI,CAACL,KAAL,CAAW,CAAX,CAAb;;AAEA,MAAI,CAACS,IAAI,CAACN,MAAV,EAAkB;AAChB,WAAOF,OAAO,CAACK,GAAG,CAACE,IAAD,CAAJ,CAAP,GAAqBD,YAArB,GAAoCD,GAAG,CAACE,IAAD,CAA9C;AACD;;AAED,SAAOJ,GAAG,CAACK,IAAD,EAAOH,GAAG,CAACE,IAAD,CAAV,EAAkBD,YAAlB,CAAV;AACD,CATD;;AAWA,MAAMG,kBAAkB,GAAG,CAACf,CAAD,EAAIgB,CAAJ,KACxB,sBAAqBhB,CAAE,qBAAoBgB,CAAE,GADhD;;AAGA,MAAMC,gBAAgB,GAAG,CAACC,SAAD,EAAYC,MAAZ,KACtB,IAAGD,SAAU,sCAAqCjB,MAAM,CAACM,IAAP,CAAYY,MAAZ,EAAoBC,IAApB,CACjD,IADiD,CAEjD,IAHJ;;AAKAC,MAAM,CAACC,OAAP,GAAiB;AACfvB,EAAAA,IADe;AAEfU,EAAAA,GAFe;AAGfM,EAAAA,kBAHe;AAIfE,EAAAA,gBAJe;AAKfX,EAAAA;AALe,CAAjB","sourcesContent":["const type = (x) => Object.prototype.toString.call(x).slice(8, -1);\n\nconst isEmpty = (x) =>\n  (type(x) === 'Object' && Object.keys(x).length === 0) ||\n  type(x) === 'Null' ||\n  type(x) === 'Undefined';\n\nconst get = (path, obj, defaultValue) => {\n  const head = path[0];\n  const tail = path.slice(1);\n\n  if (!tail.length) {\n    return isEmpty(obj[head]) ? defaultValue : obj[head];\n  }\n\n  return get(tail, obj[head], defaultValue);\n};\n\nconst withMinAndMaxMedia = (x, y) =>\n  `@media (min-width: ${x}) and (max-width: ${y})`;\n\nconst makeErrorMessage = (breakName, breaks) =>\n  `'${breakName}' is invalid breakpoint name. Use '${Object.keys(breaks).join(\n    ', '\n  )}'.`;\n\nmodule.exports = {\n  type,\n  get,\n  withMinAndMaxMedia,\n  makeErrorMessage,\n  isEmpty,\n};\n"]},"metadata":{},"sourceType":"script"}