{"ast":null,"code":"const {\n  get,\n  withMinAndMaxMedia,\n  makeErrorMessage\n} = require('./library');\n\nexports.makeStyledBreakpoints = options => {\n  const _options = options || {};\n\n  const state = {\n    pathToMediaQueries: _options.pathToMediaQueries || ['breakpoints'],\n    errorPrefix: _options.errorPrefix || '[styled-breakpoints]: ',\n    defaultMediaQueries: _options.defaultMediaQueries || {\n      xs: '0px',\n      sm: '576px',\n      md: '768px',\n      lg: '992px',\n      xl: '1200px'\n    },\n    browserContext: 16,\n\n    invariant(condition, message) {\n      if (!condition) {\n        throw new Error(state.errorPrefix + message);\n      }\n    },\n\n    throwInvalidBreakValue(breaks) {\n      Object.keys(breaks).forEach(x => {\n        state.invariant(x.indexOf('px') !== -1, `Check your theme. '${breaks[x]}' is invalid breakpoint. Use pixels.`);\n      });\n    },\n\n    throwIsInvalidBreakName(breakName, breaks) {\n      state.invariant(breaks[breakName], makeErrorMessage(breakName, breaks));\n    },\n\n    throwIsLastBreak(breakName, breaks) {\n      const names = Object.keys(breaks);\n      const penultimateBreakName = names[names.length - 2];\n      const isValid = names.indexOf(breakName) !== names.length - 1;\n      state.invariant(isValid, `Don't use '${breakName}' because it doesn't have a maximum width. Use '${penultimateBreakName}'. See https://github.com/mg901/styled-breakpoints/issues/4 .`);\n    },\n\n    throwIsInvalidNextBreakValue(name, breaks) {\n      state.invariant(breaks[name], `'${name}' is invalid breakpoint name. Use '${Object.keys(breaks).slice(0, -1).join(', ')}'.`);\n    },\n\n    throwIsInvalidOrientation(x) {\n      state.invariant(x === 'portrait' || x === 'landscape', `'${x}' is invalid orientation. Use 'landscape' or 'portrait'.`);\n    },\n\n    withOrientationOrNot(breakpoint, orientation) {\n      if (orientation) {\n        state.throwIsInvalidOrientation(orientation);\n        return `${breakpoint} and (orientation: ${orientation})`;\n      }\n\n      return breakpoint;\n    },\n\n    toEm(x) {\n      return `${parseFloat(x) / state.browserContext}em`;\n    },\n\n    getBreakpointsFromTheme() {\n      let theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return get(state.pathToMediaQueries, theme, state.defaultMediaQueries);\n    },\n\n    getNextBreakpointName(name) {\n      return breaks => {\n        state.throwIsInvalidBreakName(name, breaks);\n        state.throwIsLastBreak(name, breaks);\n        const names = Object.keys(breaks);\n        return names[names.indexOf(name) + 1];\n      };\n    },\n\n    // Maximum breakpoint width. Null for the largest (last) breakpoint.\n    // The maximum value is calculated as the minimum of the next one less 0.02px\n    // to work around the limitations of `min-` and `max-` prefixes and viewports with fractional widths.\n    // See https://www.w3.org/TR/mediaqueries-4/#mq-min-max\n    // Uses 0.02px rather than 0.01px to work around a current rounding bug in Safari.\n    // See https://bugs.webkit.org/show_bug.cgi?id=178261\n    getNextBreakpointValue(name, breaks) {\n      state.throwIsInvalidNextBreakValue(name, breaks);\n      const getNextName = state.getNextBreakpointName(name);\n      return `${parseFloat(breaks[getNextName(breaks)]) - 0.02}px`;\n    },\n\n    getBreakpointValue(name, breaks) {\n      state.throwIsInvalidBreakName(name, breaks);\n      return breaks[name];\n    },\n\n    calcMinWidth(name, theme) {\n      return state.toEm(state.getBreakpointValue(name, state.getBreakpointsFromTheme(theme)));\n    },\n\n    calcMaxWidth(name, theme) {\n      return state.toEm(state.getNextBreakpointValue(name, state.getBreakpointsFromTheme(theme)));\n    },\n\n    up(name, orientation) {\n      return props => state.withOrientationOrNot(`@media (min-width: ${state.calcMinWidth(name, props.theme)})`, orientation);\n    },\n\n    down(name, orientation) {\n      return props => state.withOrientationOrNot(`@media (max-width: ${state.calcMaxWidth(name, props.theme)})`, orientation);\n    },\n\n    between(min, max, orientation) {\n      return props => state.withOrientationOrNot(withMinAndMaxMedia(state.calcMinWidth(min, props.theme), state.calcMaxWidth(max, props.theme)), orientation);\n    },\n\n    only(name, orientation) {\n      return props => state.withOrientationOrNot(withMinAndMaxMedia(state.calcMinWidth(name, props.theme), state.calcMaxWidth(name, props.theme)), orientation);\n    }\n\n  };\n  return state;\n};","map":{"version":3,"sources":["/home/gritter/Desktop/Personal Projects/portfolio/node_modules/styled-breakpoints/core/index.js"],"names":["get","withMinAndMaxMedia","makeErrorMessage","require","exports","makeStyledBreakpoints","options","_options","state","pathToMediaQueries","errorPrefix","defaultMediaQueries","xs","sm","md","lg","xl","browserContext","invariant","condition","message","Error","throwInvalidBreakValue","breaks","Object","keys","forEach","x","indexOf","throwIsInvalidBreakName","breakName","throwIsLastBreak","names","penultimateBreakName","length","isValid","throwIsInvalidNextBreakValue","name","slice","join","throwIsInvalidOrientation","withOrientationOrNot","breakpoint","orientation","toEm","parseFloat","getBreakpointsFromTheme","theme","getNextBreakpointName","getNextBreakpointValue","getNextName","getBreakpointValue","calcMinWidth","calcMaxWidth","up","props","down","between","min","max","only"],"mappings":"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","sourcesContent":["const { get, withMinAndMaxMedia, makeErrorMessage } = require('./library');\n\nexports.makeStyledBreakpoints = (options) => {\n  const _options = options || {};\n  const state = {\n    pathToMediaQueries: _options.pathToMediaQueries || ['breakpoints'],\n    errorPrefix: _options.errorPrefix || '[styled-breakpoints]: ',\n    defaultMediaQueries: _options.defaultMediaQueries || {\n      xs: '0px',\n      sm: '576px',\n      md: '768px',\n      lg: '992px',\n      xl: '1200px',\n    },\n    browserContext: 16,\n\n    invariant(condition, message) {\n      if (!condition) {\n        throw new Error(state.errorPrefix + message);\n      }\n    },\n    throwInvalidBreakValue(breaks) {\n      Object.keys(breaks).forEach((x) => {\n        state.invariant(\n          x.indexOf('px') !== -1,\n          `Check your theme. '${breaks[x]}' is invalid breakpoint. Use pixels.`\n        );\n      });\n    },\n    throwIsInvalidBreakName(breakName, breaks) {\n      state.invariant(breaks[breakName], makeErrorMessage(breakName, breaks));\n    },\n    throwIsLastBreak(breakName, breaks) {\n      const names = Object.keys(breaks);\n      const penultimateBreakName = names[names.length - 2];\n      const isValid = names.indexOf(breakName) !== names.length - 1;\n\n      state.invariant(\n        isValid,\n        `Don't use '${breakName}' because it doesn't have a maximum width. Use '${penultimateBreakName}'. See https://github.com/mg901/styled-breakpoints/issues/4 .`\n      );\n    },\n    throwIsInvalidNextBreakValue(name, breaks) {\n      state.invariant(\n        breaks[name],\n        `'${name}' is invalid breakpoint name. Use '${Object.keys(breaks)\n          .slice(0, -1)\n          .join(', ')}'.`\n      );\n    },\n    throwIsInvalidOrientation(x) {\n      state.invariant(\n        x === 'portrait' || x === 'landscape',\n        `'${x}' is invalid orientation. Use 'landscape' or 'portrait'.`\n      );\n    },\n    withOrientationOrNot(breakpoint, orientation) {\n      if (orientation) {\n        state.throwIsInvalidOrientation(orientation);\n\n        return `${breakpoint} and (orientation: ${orientation})`;\n      }\n\n      return breakpoint;\n    },\n    toEm(x) {\n      return `${parseFloat(x) / state.browserContext}em`;\n    },\n    getBreakpointsFromTheme(theme = {}) {\n      return get(state.pathToMediaQueries, theme, state.defaultMediaQueries);\n    },\n    getNextBreakpointName(name) {\n      return (breaks) => {\n        state.throwIsInvalidBreakName(name, breaks);\n        state.throwIsLastBreak(name, breaks);\n\n        const names = Object.keys(breaks);\n\n        return names[names.indexOf(name) + 1];\n      };\n    },\n    // Maximum breakpoint width. Null for the largest (last) breakpoint.\n    // The maximum value is calculated as the minimum of the next one less 0.02px\n    // to work around the limitations of `min-` and `max-` prefixes and viewports with fractional widths.\n    // See https://www.w3.org/TR/mediaqueries-4/#mq-min-max\n    // Uses 0.02px rather than 0.01px to work around a current rounding bug in Safari.\n    // See https://bugs.webkit.org/show_bug.cgi?id=178261\n\n    getNextBreakpointValue(name, breaks) {\n      state.throwIsInvalidNextBreakValue(name, breaks);\n      const getNextName = state.getNextBreakpointName(name);\n\n      return `${parseFloat(breaks[getNextName(breaks)]) - 0.02}px`;\n    },\n    getBreakpointValue(name, breaks) {\n      state.throwIsInvalidBreakName(name, breaks);\n\n      return breaks[name];\n    },\n    calcMinWidth(name, theme) {\n      return state.toEm(\n        state.getBreakpointValue(name, state.getBreakpointsFromTheme(theme))\n      );\n    },\n    calcMaxWidth(name, theme) {\n      return state.toEm(\n        state.getNextBreakpointValue(name, state.getBreakpointsFromTheme(theme))\n      );\n    },\n    up(name, orientation) {\n      return (props) =>\n        state.withOrientationOrNot(\n          `@media (min-width: ${state.calcMinWidth(name, props.theme)})`,\n          orientation\n        );\n    },\n    down(name, orientation) {\n      return (props) =>\n        state.withOrientationOrNot(\n          `@media (max-width: ${state.calcMaxWidth(name, props.theme)})`,\n          orientation\n        );\n    },\n    between(min, max, orientation) {\n      return (props) =>\n        state.withOrientationOrNot(\n          withMinAndMaxMedia(\n            state.calcMinWidth(min, props.theme),\n            state.calcMaxWidth(max, props.theme)\n          ),\n          orientation\n        );\n    },\n    only(name, orientation) {\n      return (props) =>\n        state.withOrientationOrNot(\n          withMinAndMaxMedia(\n            state.calcMinWidth(name, props.theme),\n            state.calcMaxWidth(name, props.theme)\n          ),\n          orientation\n        );\n    },\n  };\n\n  return state;\n};\n"]},"metadata":{},"sourceType":"script"}